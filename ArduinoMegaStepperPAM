// Stepper motor control for PAM by Aduino Mega (16 MHz clock frequency)
// Use Timer 1, 3, 4 (all are 16 bit timer) to generate PWM step pulse with S-curve speed up. 

// Serial communication baud rate: 19200
// Mode: 
//    Mode = Serial.parseInt(); 
//    V1 =  Serial.parseInt(); 
//    V2 =  Serial.parseInt(); 
//    V3 =  Serial.parseInt(); 
//    V4 =  Serial.parseInt(); 
//    V5 =  Serial.parseInt(); 
//    V6 =  Serial.parseInt(); 
  
// 
// Mode setting: 
// 
// Mode 0: stop everything. 
// Input: 0
//
// Mode 1: start laser trigger (without stepper motor control)
// Input: 1 TrigRate
// Example: 1 1000
// (The first variable defines the mode) it generates 1000 Hz continuous trigger. (default 50% cycle)
//
// Mode 2: Control stepper motor along one axis (with synchronized laser trigger)
// Input: 2 xyz steps dir en frequency(/10) StepTrig
// Example: 2 1 1000 1 1 900 3
// It move x-axis by 1000 steps, at + direction, enabled, at 9000 Hz (900*10), and generate 1 laser trigger every 3 steps. 
// For y- and z-axis, the laser trigger has no effect. '
// 'xyz' is the choice of axis. 1: x; 2: y; 3: z. 
//
// Mode 3: Control 3-axis of motor to perform a 3D raster scanning. 
// Input: 3 x_steps x_dir y_steps y_dir z_steps z_dir
// (not fully finished yet)


// Pin Usage: 
// D12: Step pin X (fast axis by default) (TIOA of Timer 1)
//  D2: Step pin Y                        (TIOA of Timer 3)
//  D7: Step pin Z                        (TIOA of Timer 4)
// 
// D13: Enable pin for step pulse. (An external logic AND IC SN74LS08 multiply D13 and D12 (or D2, D7) to gate the step pulses)
// (There is a random trigger when reinitializing Timer 1, 3 and 4. D13 is used to solve this problem. This problem only occurs in Mega)
// 
// D37: Direction pin X (two choice: HIGH or LOW)
// D36: Direction pin Y
// D35: Direction pin Z
//
// D45: Laser trigger pin. 


#include <math.h>

const int SnMax = 300; // Whole steps of speed up curve. Maximal to 900, due to the limitation of memory in Mega. 

int ii;
int nx = -1;  // Step counter number. Begins from -1, since in the first two counter cycle, there is no PWM output. 
int ny = -1;
int nz = -1;
int nn5 = 0; // for trigger at Timer 5

float ObjFre = 90000; // Maximal 120 kHz PWM for Mega
float StaFre = 320; 
float v0, v1, v2; 

//int Steps = 100;  // Whole steps.
//int Dir; // Direction

int Mode; // Operating mode. 
int xyz; // choose which axis for moving.
int x_steps, y_steps, z_steps;
int x_dir, y_dir, z_dir;
int x_en, y_en, z_en;
int Frequency; // Target frequency of steppor motor = laser trigger frequency * StepTrig.
int StepTrig; // generate one trigger every N steps.
int TrigN = 1;
int TrigRate;
int Timer5Mode; // Mode 2: Continuous or N trigger | Mode 1: just single trigger (16 us, )

int steps, dir, en;

// Serial port command variable (integers). 
int V1, V2, V3, V4, V5, V6;


int Sn; // Speed up/down steps. 
float Ac; // Acceleration rate of speed up curve. 
float T1, T2; // S-curve t1 and t2. t1 is the midpoint time, t2 is the end time.

float ScTable[SnMax];

int RAx, RAy, RAz;
int RBx, RBy, RBz;
int RA5, RB5; // RA5, RB5 are register value for

int RB0 = 30;

// LED indicator pin. Red means laser trigger is on. 
int LED_Red = 69; 
int LED_Green = 68; 
int LED_Blue = 67; 

// Movemeng information. 0: Busy; 1: Finished; 2: Wait; 
int MoveStatus = 2; // 0: Busy; 1: Finished; 2: Wait; 
int MoveStatusX = 2;
int MoveStatusX2 = 2; // forward/backward move
int MoveStatusY = 2;
int MoveStatusZ = 2; 


void setup()
{
  Serial.begin (19200) ; //
  Serial.setTimeout(40);
  Serial.flush();
  
  pinMode(13, OUTPUT);  // Pin 13 is the switch pin. 
  pinMode(12, OUTPUT);  // Pin 12 is the PWM output of Timer 1.
  pinMode(2, OUTPUT);  // Pin 2 is the PWM output of Timer 3.
  pinMode(7, OUTPUT);  // Pin 7 is the PWM output of Timer 4. 
  pinMode(45, OUTPUT); // Pin 45 is the Trigger output of Timer 5. For laser trigger. 

  pinMode(37, OUTPUT); // x direction. 
  pinMode(36, OUTPUT); // y direction. 
  pinMode(35, OUTPUT); // z direction. 

  pinMode(LED_Red, OUTPUT); 
  pinMode(LED_Blue, OUTPUT); 
  pinMode(LED_Green, OUTPUT); 

  DDRB = DDRB | B10000000; // Use D13 (PB7) as switch.
  PORTB = B00000000; // Port manipulation. 

  DDRC = DDRC | B00000111; // Use D37, D36, D35 as x, y, z direction.
  PORTC = B00000111;

  // Initialization.
  startTimer5(RA5, RB5);
  Gen1Pulse(); 
  delay(100); 
//  x_steps = 5;
//  startTimer1(0, 0);
  MakeScurve(ObjFre);
//  Serial.println(floor(ScTable[0] * 1000000 / 4));

  digitalWrite(LED_Green, HIGH); 
}

void loop()
{
  MoveStatus = MoveStatusX * MoveStatusY * MoveStatusZ; 
  
  if (MoveStatusX==1) {
    Serial.println("1 X"); 
    MoveStatusX = 2; 
  }

  if (MoveStatusY==1) {
    Serial.println("1 Y"); 
    MoveStatusY = 2; 
  }

  if (MoveStatusZ==1) {
    Serial.println("1 Z"); 
    MoveStatusZ = 2; 
  }  
  
  if (Serial.available() > 0) {  // Accept serial command. 
    Mode = Serial.parseInt(); 
    V1 =  Serial.parseInt(); 
    V2 =  Serial.parseInt(); 
    V3 =  Serial.parseInt(); 
    V4 =  Serial.parseInt(); 
    V5 =  Serial.parseInt(); 
    V6 =  Serial.parseInt(); 
    Serial.flush(); 
    
    if (Mode == 1) {  // Turn on laser trigger (without stepper motor control)
      TrigOff(); 
      PORTB = B00000000;
      delay(10); 
      digitalWrite(LED_Green, LOW); 
      digitalWrite(LED_Red, HIGH); 
      TrigRate = V1; 
      if (TrigRate <= 0) {
        TrigRate = 1000; 
      }
      TrigN = V2; 
      TrigOn(TrigRate); 
      Serial.println("Trig"); 
    }

    else if (Mode == 2) {  // Control stepper motor (with synchronized laser trigger)
      MoveStatus = 0; 
      TrigOff(); 
      PORTB = B00000000;
      xyz = V1; 
      steps = V2; 
      dir = V3; 
      en = V4; 
      Frequency = V5; 
      StepTrig = V6;
      
      ObjFre = float(Frequency)*10;
      
//      Serial.print("Frequency: "); 
//      Serial.println(ObjFre); 
      
      MakeScurve(ObjFre);

      if ( (xyz==1) && (StepTrig>0) ) {
        digitalWrite(LED_Green, LOW); 
        digitalWrite(LED_Red, HIGH); 
      }
      else {
        digitalWrite(LED_Red, LOW); 
        digitalWrite(LED_Green, HIGH); 
      }      

    if ( (xyz == 1)&&(MoveStatusX==2) ) {
      MoveStatusX = 0; 
      x_steps = steps;
      x_dir = dir;
      x_en = en;

  //    Serial.print("X ");
 //     Serial.print(x_steps);
  //    Serial.print(" ");
  //    Serial.print(x_dir);
  //    Serial.print(" ");
 //     Serial.println(StepTrig);

      if (x_dir==1) {
        digitalWrite(37, HIGH); 
      }
      else {
        digitalWrite(37, LOW); 
      }

      stopTimer1();
      if (StepTrig != 0) {
        Gen1Pulse();
      }
      delayMicroseconds(500);
      //    Gen1Pulse();
      RAx = floor(ScTable[0] * 1000000 / 4);
      RBx =  RAx / 2;
      startTimer1(RAx, RBx);
      
    }

    else if ( (xyz == 2)&&(MoveStatusY==2) ) { 
      MoveStatusY = 0; 
      y_steps = steps;
      y_dir = dir;
      y_en = en;

//      Serial.print("Y ");
//      Serial.print(y_steps);
//      Serial.print(" ");
//      Serial.print(y_dir);
//      Serial.print(" ");
//      Serial.println(StepTrig);
      
      if (y_dir==1) {
        digitalWrite(36, HIGH); 
      }
      else {
        digitalWrite(36, LOW); 
      }

      stopTimer3();
//      if (StepTrig != 0) {
//        Gen1Pulse();
//      }
      delayMicroseconds(500);
      RAy = floor(ScTable[0] * 1000000 / 4);
      RBy =  RAy / 2;
      startTimer3(RAy, RBy);      
    } 

    else if ( (xyz == 3)&&(MoveStatusZ==2) ) {
      MoveStatusZ = 0; 
      z_steps = steps;
      z_dir = dir;
      z_en = en;

//      Serial.print("Z ");
//      Serial.print(z_steps);
//      Serial.print(" ");
//      Serial.print(z_dir);
//      Serial.print(" ");
//      Serial.println(StepTrig);

      if (z_dir==1) {
        digitalWrite(35, HIGH); 
      }
      else {
        digitalWrite(35, LOW); 
      }

      stopTimer4();
//      if (StepTrig != 0) {
//        Gen1Pulse();
//      }
      delayMicroseconds(500);
      RAz = floor(ScTable[0] * 1000000 / 4);
      RBz = RAz / 2;
      startTimer4(RAz, RBz); 
    } 
      
    else if ( (MoveStatusX==0)||(MoveStatusY==0)||(MoveStatusZ==0) ) { // It is still busy before take next action. 
      Serial.println("MoveStatusX: 0 BUSY"); 
    }
    
    } // End of Mode 2
  
      
    else if (Mode == 3) {  // Not fully finished yet
      TrigOff(); 
      PORTB = B00000000; 
      stopTimer1();
      stopTimer3();
      stopTimer4();
      digitalWrite(LED_Red, LOW); 
      digitalWrite(LED_Green, HIGH);   
      
      x_steps = V1; 
      x_dir = V2; 
      x_en = 1; 
      y_steps = V3; 
      y_dir = V4; 
      y_en = 1; 
      z_steps = V5; 
      z_dir = V6; 
      z_en = 1;
      
      ObjFre = 3000; 
      MakeScurve(ObjFre);
      StepTrig = 0;
      
      if (x_dir==1) {
        digitalWrite(37, HIGH); 
      }
      else {
        digitalWrite(37, LOW); 
      }
      
      if (y_dir==1) {
        digitalWrite(36, HIGH); 
      }
      else {
        digitalWrite(36, LOW); 
      }
      
      if (z_dir==1) {
        digitalWrite(35, HIGH); 
      }
      else {
        digitalWrite(35, LOW); 
      }      
      
      delayMicroseconds(500);
      //    Gen1Pulse();
      RAx = floor(ScTable[0] * 1000000 / 4);
      RBx =  RAx / 2;
      startTimer1(RAx, RBx);  
      
      RAy = floor(ScTable[0] * 1000000 / 4);
      RBy =  RAy / 2;
      startTimer3(RAy, RBy);  
      
      RAz = floor(ScTable[0] * 1000000 / 4);
      RBz = RAz / 2;
      startTimer4(RAz, RBz);           
    }
    
    else {         // (Mode == 0) 
      TrigOff(); 
      PORTB = B00000000; 
      stopTimer1();
      stopTimer3();
      stopTimer4();
      digitalWrite(LED_Red, LOW); 
      digitalWrite(LED_Green, HIGH);   
      Serial.println("0"); 
    }

  }
}


void MakeScurve(float Freq2) {
  v2 = Freq2; 
  v0 = max(v2 / 40, 80); 
  v1 = (v2 + v0) / 2;
  Sn = min(Freq2 / 6, SnMax);
//  Serial.println(Freq2); 
//  Serial.println(Sn); 
  Ac =  (v2 + v0) * sqrt(v2 - v0) / float(Sn) ;
  Ac = Ac * Ac; // Divide into two steps, just avoid floating overflow (Arduino float type<3.0e8).
  T2 = 2 * sqrt( (v2 - v0) / Ac);
  T1 = T2 / 2;
  makeScTable(v0, v2, T1, T2, Sn, ScTable);
}


void startTimer1(int RA, int RB) {  // Start timer 1 for X-dircection PWM steps. 

  TIMSK1 = bit (OCIE1A) | bit (OCIE1B);

  // Non-inverting output
  TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11) | _BV(WGM10);
  // Inverting output
  //  TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11) | _BV(WGM10);

  TCCR1B = _BV(WGM12) | _BV(WGM13) | _BV(CS11) | _BV(CS10); // Scaling: 64 ; Unit: 4 us for one counter.

  OCR1A = RA; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
  OCR1B = (RA / 2) - 1; //RA - RB; // // Unit time: 4 us

}


void startTimer3(int RA, int RB) { // Start timer 3 for X-dircection PWM steps. 

  TIMSK3 = bit (OCIE3A);

  // Non-inverting output
  TCCR3A = _BV(COM3B1) | _BV(COM3B0) | _BV(WGM31) | _BV(WGM30);
  // Inverting output
  //  TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11) | _BV(WGM10);

  TCCR3B = _BV(WGM32) | _BV(WGM33) | _BV(CS31) | _BV(CS30); // Scaling: 64 ; Unit: 4 us for one counter.

  OCR3A = RA; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
  OCR3B = (RA / 2) - 1; //RA / 2; //RA - RB; // // Unit time: 4 us

}

void startTimer4(int RA, int RB) { // Start timer 4 for X-dircection PWM steps. 

  TIMSK4 = bit (OCIE4A); 

  // Non-inverting output
  TCCR4A = _BV(COM4B1) | _BV(COM4B0) | _BV(WGM41) | _BV(WGM40);
  // Inverting output
  //  TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11) | _BV(WGM10);

  TCCR4B = _BV(WGM42) | _BV(WGM43) | _BV(CS41) | _BV(CS40); // Scaling: 64 ; Unit: 4 us for one counter.

  OCR4A = RA; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
  OCR4B = (RA / 2) - 1; // RA / 2; //RA - RB; // // Unit time: 4 us

}

void stopTimer1() {
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  TIMSK1 = 0;
  TIFR1 = 0;
}

void stopTimer3() { 
  TCCR3A = 0;
  TCCR3B = 0;
  TCNT3 = 0;
  TIMSK3 = 0;
  TIFR3 = 0;
}

void stopTimer4() {
  TCCR4A = 0;
  TCCR4B = 0;
  TCNT4 = 0;
  TIMSK4 = 0;
  TIFR4 = 0;
}


ISR(TIMER1_COMPA_vect)        // interrupt service routine for Timer 1. Trigger when counter reach Register OCR1B. Generate Step PWM. 
{
  if ((nx == 0) && (Mode == 2)) {
    PORTB = B10000000 * x_en;
//    digitalWrite(13, HIGH); 
  }


//  if ((nx >= 1) && (StepTrig != 0))  {
//    if (nx % StepTrig == 0)
//    {
//      Gen1Pulse();
//    }
//  }

  nx++;

  if (x_steps > 2 * Sn) // If x_steps is larger than the sum of speed up and down steps, there is a constant speed range. 
  {
    if (nx < x_steps)
    {
      if (nx < Sn)
      {
        RAx = round(ScTable[nx] * 1000000 / 4);
        OCR1A = RAx; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR1B = RAx / 2; // OCR1A - RB; // // Unit time: 4 us
      }

      if (nx > x_steps - Sn)
      {
        RAx = round(ScTable[x_steps - nx - 2] * 1000000 / 4);
        OCR1A = RAx; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR1B = RAx / 2; // OCR1A - RB; // // Unit time: 4 us
      }
    }
    else
    {
      stopTimer1();
 //     PORTB = B00000000;
      nx = -1;
      digitalWrite(LED_Red, LOW); 
      digitalWrite(LED_Green, HIGH); 
      MoveStatusX = 1; 
    }
  }

  else // If x_steps is smaller than the sum of speed up and down steps, it will speed down before it reqch maximal speed. 
  {
    if (nx < x_steps)
    {
      if (nx < floor(x_steps / 2))
      {
        RAx = round(ScTable[nx] * 1000000 / 4); ;
        OCR1A = RAx; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR1B = RAx / 2; //OCR1A - RB; // // Unit time: 4 us
      }

      else
      {
        RAx = round(ScTable[x_steps - nx - 2] * 1000000 / 4); ;
        OCR1A = RAx; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR1B = RAx / 2; //OCR1A - RB; // // Unit time: 4 us
      }
    }
    else
    {
      stopTimer1();
//        PORTB = B00000000;
      nx = -1; 
      digitalWrite(LED_Red, LOW); 
      digitalWrite(LED_Green, HIGH); 
      MoveStatusX = 1; 
    }
  }

}


ISR(TIMER1_COMPB_vect)        // interrupt service routine of Timer 1. Interrupted when counter reach Register OCR1B. generate Laser trigger. 
{

//  if (nx == 1) {
//    PORTB = B10000000 * x_en;
////    digitalWrite(13, HIGH); 
//  }


  if ((nx >= 1) && (StepTrig != 0))  {
    if (nx % StepTrig == 0)
    {
      Gen1Pulse();
    }
  }

}


ISR(TIMER3_COMPA_vect)        // interrupt service routine. For Step Y. 
{
  if ((ny == 0) && (Mode == 2)) {
    PORTB = B10000000 * y_en;
  }

  ny++;

  if (y_steps > 2 * Sn)
  {
    if (ny < y_steps)
    {
      if (ny < Sn)
      {
        RAy = round(ScTable[ny] * 1000000 / 4);
        OCR3A = RAy; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR3B = RAy / 2; // OCR1A - RB; // // Unit time: 4 us
      }

      if (ny > y_steps - Sn)
      {
        RAy = round(ScTable[y_steps - ny - 2] * 1000000 / 4);
        OCR3A = RAy; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR3B = RAy / 2; // OCR1A - RB; // // Unit time: 4 us
      }
    }
    else
    {
      stopTimer3();
//        PORTB = B00000000;
      ny = -1;
      MoveStatusY = 1; 
    }
  }

  else
  {
    if (ny < y_steps)
    {
      if (ny < floor(y_steps / 2))
      {
        RAy = round(ScTable[ny] * 1000000 / 4); ;
        OCR3A = RAy; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR3B = RAy / 2; //OCR1A - RB; // // Unit time: 4 us
      }

      else
      {
        RAy = round(ScTable[y_steps - ny - 2] * 1000000 / 4); ;
        OCR3A = RAy; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR3B = RAy / 2; //OCR1A - RB; // // Unit time: 4 us
      }
    }
    else
    {
      stopTimer3();
//      PORTB = B00000000;
      ny = -1;
      MoveStatusY = 1; 
    }
  }

}



ISR(TIMER4_COMPA_vect)        // interrupt service routine. For Step Z. 
{
  if (nz == 0) {
    PORTB = B10000000 * z_en;
    //    Serial.print(z_steps);
  }

  nz++;

  if (z_steps > 2 * Sn)
  {
    if (nz < z_steps)
    {
      if (nz < Sn)
      {
        RAz = round(ScTable[nz] * 1000000 / 4);
        OCR4A = RAz; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR4B = RAz / 2; // OCR1A - RB; // // Unit time: 4 us
      }

      if (nz > z_steps - Sn)
      {
        RAz = round(ScTable[z_steps - nz - 2] * 1000000 / 4);
        OCR4A = RAz; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR4B = RAz / 2; // OCR1A - RB; // // Unit time: 4 us
      }
    }
    else
    {
      stopTimer4();
 //     PORTB = B00000000;
      nz = -1;
      MoveStatusZ = 1; 
    }
  }

  else
  {
    if (nz < z_steps)
    {
      if (nz < floor(z_steps / 2))
      {
        RAz = round(ScTable[nz] * 1000000 / 4); ;
        OCR4A = RAz; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR4B = RAz / 2; //OCR1A - RB; // // Unit time: 4 us
      }

      else
      {
        RAz = round(ScTable[z_steps - nz - 2] * 1000000 / 4); ;
        OCR4A = RAz; // 180;  // 16 MHz / 64 / (250+1)   // f=250000Hz/OCR1A
        OCR4B = RAz / 2; //OCR1A - RB; // // Unit time: 4 us
      }
    }
    else
    {
      stopTimer4();
//      PORTB = B00000000;
      nz = -1; 
      MoveStatusZ = 1; 
    }
  }

}


// Make table for S-shape speed up curve. 
float makeScTable(float v0, float v2, float T1, float T2, int Sn, float ScTable[]) 
{
  float td_ac[Sn];
  int nn = 0;

  // Serial.println("Make table: ");

  ScTable[0] = 1 / vt1f(0);
  td_ac[0] = 0;

  //  Serial.println(vt1f(0));

  while (td_ac[nn] < T2)
  {
    nn = nn + 1;
    td_ac[nn] = td_ac[nn - 1] + ScTable[nn - 1];
    if (td_ac[nn] < T1)
    {
      ScTable[nn] = 1 / vt1f(td_ac[nn]);
      //      Serial.print(td_ac[nn], 5);
      //      Serial.print("  ");
      //      Serial.println(vt1f(td_ac[nn]), 3);
    }
    else
    {
      ScTable[nn] = 1 / vt2f(td_ac[nn]);
      //      Serial.print(td_ac[nn], 5);
      //      Serial.print("  ");
      //      Serial.println(vt2f(td_ac[nn]), 3);
    }
  }

  //  Serial.println(nn);

}


float vt1f(float tt)
{
  float vout;
  vout = v0 + 0.5 * Ac * tt * tt;
  return vout;
}


float vt2f(float tt)
{
  float vout;
  vout = 2 * Ac * tt * sqrt(2 * (v1 - v0) / Ac) - 0.5 * Ac * tt * tt - 2 * v1 + 3 * v0;
  return vout;
}


// ======================= //// ======================= //// ======================= //

// Just generate one pulse
void Gen1Pulse() {
  Timer5Mode = 1;
//  stopTimer5();
  TrigN = 1;
  startTimer5(RA5, RB5);
  return;
}

// Generate N pulse. 
void GenNPulse(int n) {
  Timer5Mode = 2;
  stopTimer5();
  TrigN = n;
  startTimer5(RA5, RB5);
  return;
}

//void DelaySwitchOn13(int RA) {
//  
//}

void TrigOn(int frequency) {
  Timer5Mode = 3;
//  stopTimer5();
//  TrigN = 0;
  RA5 = 125000 / frequency;
  startTimer5(RA5, RB5);
  return;
}

void TrigOnB(int frequency, int rb) { // rb in unit 8 us;
  Timer5Mode = 3;
  stopTimer5();
  TrigN = 0;
  RA5 = 125000 / frequency;
  startTimer5(RA5, min(rb, RA5 - 2));
  return;
}

void TrigOff() {
  stopTimer5();
  return;
}

void startTimer5(int ra, int rb) {

  TIMSK5 = bit (OCIE5A);

  //switch (Timer5Mode) {

//  if (Timer5Mode == 1) { // single trigger (time delay ~30 us)
//    TCCR5A = _BV(COM5B1)  |  _BV(WGM51) |  _BV(WGM50);
//    TCCR5B = _BV(WGM53) | _BV(CS50); // Scaling: 1 ; Unit: 0.125 us for one counter.
//    OCR5A = 450; // 400; // 40 us period
//    OCR5B = 200; // 200; // 25 us On
//  }

// CTC Mode. 
  if (Timer5Mode == 1) { // single trigger (time delay ~30 us)
    TCCR5A = _BV(COM5B1) | _BV(COM5B0) ;// |  _BV(WGM51) |  _BV(WGM50);
    TCCR5B = _BV(WGM52) | _BV(CS50); // Scaling: 1 ; Unit: 0.125 us for one counter.
    OCR5A = 120; // Generate 25 us pulse 
  }

  if (Timer5Mode == 2) { // Generate N trigger (fixed 1 kHz. Dutation fixed at 25 us)
    TCCR5A =   _BV(COM5B1)  |  _BV(WGM51) |  _BV(WGM50);
    TCCR5B = _BV(WGM53) | _BV(CS51); // Scaling: 8 ; Unit: 1 us for one counter.
    OCR5A = 1000; // 1ms period, i.e. 1 kHz
    OCR5B = 25;   // Unit time: 1 us
  }

  if (Timer5Mode == 3) { // continuous Trig On mode (frequency variable. Dutation fixed at 32 us)
    TCCR5A =   _BV(COM5B1)  |  _BV(WGM51) |  _BV(WGM50);
    TCCR5B = _BV(WGM53) | _BV(CS51) | _BV(CS50); // | _BV(CS50); // Scaling: 64 ; Unit: 8 us for one counter.
    OCR5A = ra; // 1ms period, i.e. 1 kHz
    OCR5B = 4;  // Unit time: 8 us
  }

  if (Timer5Mode == 4) { // Free mode. Frequency & Duty variable.
    TCCR5A =   _BV(COM5B1)  |  _BV(WGM51) |  _BV(WGM50);
    TCCR5B = _BV(WGM53) | _BV(CS51) | _BV(CS50); // | _BV(CS50); // Scaling: 8 ; Unit: 1 us for one counter.
    OCR5A = ra; // Unit time: 8 us
    OCR5B = rb; // Unit time: 8 us
  }

}

void stopTimer5() {
  TCCR5A = 0;
  TCCR5B = 0;
  TIMSK5 = 0;
  TIFR5 = 0;
  TCNT5 = 0;
  nn5 = 0;
}

ISR(TIMER5_COMPA_vect)        // interrupt service routine 
{
  nn5++;
  if (nn5 == 1) {
    //    PORTB = B10000000;
  }
  else if (nn5 == TrigN + 1) { // nn=3, then generate 1 trigger at pin 9.
    stopTimer5();
    digitalWrite(LED_Green, HIGH); 
    digitalWrite(LED_Red, LOW); 
    //    PORTB = B00000000;
  }
}

